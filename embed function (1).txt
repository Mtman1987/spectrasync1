# VIP Live Embed Function - Full Code Documentation

This document contains the final, working TypeScript code for the multi-part, automated system for VIP live announcements.

## Core Concepts

1.  **Stateless Cron Jobs:** The system relies on two separate serverless functions (Next.js API routes) called by external cron job schedulers. They are stateless and manage their state through Firestore.
2.  **Background Processing:** GIF generation, which is slow, is handled by a separate background process. This ensures the main live announcements are fast and reliable.
3.  **AI-Powered Content:** Shoutout messages are dynamically generated by an AI flow once every 24 hours, keeping the content fresh and exciting.
4.  **State Management in Firestore:** The system uses Firestore to store generated GIF URLs, AI-generated messages, timestamps for cooldowns, and the message IDs of announcements posted to Discord.

---

## Part 1: Main Announcement Cron Job

This is the primary process that runs frequently (e.g., every 7 minutes) to manage the live announcements in Discord.

**File:** `/src/app/api/bot/cron/route.ts`

```typescript
// src/app/api/bot/cron/route.ts
import { NextResponse, type NextRequest } from 'next/server';
import { getAdminDb } from '@/lib/firebase-admin';
import { getTwitchStreams } from '@/app/actions';
import { postToWebhook, editWebhookMessage, deleteWebhookMessage } from '@/bot/discord-actions';
import { FieldValue, Timestamp } from 'firebase-admin/firestore';
import { generateVipShoutout } from '@/ai/flows/generate-vip-shoutout';
import { getUsersFromDb } from '@/app/actions';

const db = getAdminDb();

// --- Types ---
type LiveUser = {
  twitchId: string;
  twitchLogin: string;
  displayName: string;
  avatarUrl: string;
  latestGameName: string;
  latestViewerCount: number;
  latestStreamTitle?: string;
  vipMessage?: string;
  started_at?: string;
  discordId?: string; // Ensure discordId is available
  vipMessageLastGenerated?: Timestamp;
};

// --- Firestore Helpers ---

async function getVipTwitchIds(guildId: string): Promise<string[]> {
    const snapshot = await db.collection(`communities/${guildId}/users`).where('isVip', '==', true).get();
    if (snapshot.empty) return [];
    return snapshot.docs.map(doc => doc.data().twitchInfo?.id).filter(Boolean);
}

// --- Discord Embed Builders ---

function buildVipEmbed(vip: LiveUser, gifUrl: string | null) {
    const embed = {
        author: { name: vip.displayName, icon_url: vip.avatarUrl, url: `https://twitch.tv/${vip.twitchLogin}` },
        title: vip.latestStreamTitle || 'Untitled Stream',
        url: `https://twitch.tv/${vip.twitchLogin}`,
        description: `*${vip.vipMessage || 'Come hang out!'}*`,
        color: 0x9146FF, // Twitch Purple
        fields: [
            { name: 'Playing', value: vip.latestGameName || 'N/A', inline: true },
            { name: 'Viewers', value: vip.latestViewerCount.toString(), inline: true }
        ],
        thumbnail: { url: vip.avatarUrl },
        timestamp: new Date().toISOString(),
        image: gifUrl ? { url: gifUrl } : undefined
    };
        
    return embed;
}

// --- Main Bot Logic ---

async function processVip(guildId: string, vip: LiveUser, webhookUrl: string, existingMessageId?: string) {
    let gifUrl: string | null = null;
    let processedVip = { ...vip };

    try {
        // AI Shoutout Generation with 24-hour cooldown
        const now = Date.now();
        const lastGenerated = vip.vipMessageLastGenerated?.toMillis() || 0;
        const shouldGenerateMessage = !vip.vipMessage || (now - lastGenerated > 24 * 60 * 60 * 1000);

        if (shouldGenerateMessage && vip.discordId) {
            try {
                const shoutoutResult = await generateVipShoutout({ vipName: vip.displayName });
                processedVip.vipMessage = shoutoutResult.shoutoutMessage;

                // Update the database with the new message and timestamp
                const userRef = db.collection(`communities/${guildId}/users`).doc(vip.discordId);
                await userRef.update({
                    vipMessage: processedVip.vipMessage,
                    vipMessageLastGenerated: FieldValue.serverTimestamp()
                });

            } catch (aiError) {
                console.error(`AI message generation failed for ${vip.displayName}:`, aiError);
                // Fallback to existing message if generation fails
                processedVip.vipMessage = vip.vipMessage || 'Come hang out and watch the stream!';
            }
        }


        // GIF Selection
        if (vip.discordId) {
            const gifsSnapshot = await db.collection(`communities/${guildId}/users/${vip.discordId}/generatedGifs`).get();
            if (!gifsSnapshot.empty) {
                const gifs = gifsSnapshot.docs.map(doc => doc.data().gifUrl);
                gifUrl = gifs[Math.floor(Math.random() * gifs.length)];
            }
        }
    } catch (error) {
        console.error(`Could not fetch GIFs or generate message for ${vip.displayName}:`, error);
    }
        
    const embed = buildVipEmbed(processedVip, gifUrl);
    const payload = { embeds: [embed] };

    if (existingMessageId) {
        await editWebhookMessage(webhookUrl, existingMessageId, payload);
        return existingMessageId;
    } else {
        const message = await postToWebhook(webhookUrl, payload);
        return message ? message.id : null;
    }
}


async function runVipCheckForGuild(guildId: string) {
    const settingsDoc = await db.collection(`communities/${guildId}/settings`).doc('vipLive').get();
    if (!settingsDoc.exists) {
        console.log(`[Cron] No VIP config for guild ${guildId}. Skipping.`);
        return;
    }
    const config = settingsDoc.data()!;
    const webhookUrl = config.webhookUrl;
    let messageIds: { [twitchId: string]: string } = config.vipMessageIds || {};

    if (!webhookUrl) {
        console.log(`[Cron] No webhook URL for guild ${guildId}. Skipping.`);
        return;
    }

    const vipTwitchIds = await getVipTwitchIds(guildId);
    if (vipTwitchIds.length === 0) {
        // If no VIPs are configured, delete all old messages.
        if (Object.keys(messageIds).length > 0) {
            for (const messageId of Object.values(messageIds)) {
                await deleteWebhookMessage(webhookUrl, messageId);
            }
            await db.collection(`communities/${guildId}/settings`).doc('vipLive').set({ vipMessageIds: {} }, { merge: true });
        }
        return;
    }
    
    const [dbUsers, liveStreams] = await Promise.all([
        getUsersFromDb(guildId, vipTwitchIds),
        getTwitchStreams(vipTwitchIds)
    ]);

    const liveStreamMap = new Map(liveStreams.map(s => [s.user_id, s]));

    const liveVips: LiveUser[] = dbUsers
        .map(user => {
            const streamData = liveStreamMap.get(user.twitchId);
            if (!streamData) return null;
            return { ...user, ...streamData, latestGameName: streamData.game_name, latestViewerCount: streamData.viewer_count, latestStreamTitle: streamData.title };
        })
        .filter((u): u is LiveUser => u !== null);

    const liveVipIds = new Set(liveVips.map(v => v.twitchId));
    const postedVipIds = new Set(Object.keys(messageIds));
    const newMessages: { [twitchId: string]: string } = {};

    // Delete messages for VIPs who went offline
    for (const twitchId of postedVipIds) {
        if (!liveVipIds.has(twitchId)) {
            await deleteWebhookMessage(webhookUrl, messageIds[twitchId]);
        }
    }

    // Process live VIPs (add new ones, update existing ones)
    for (const vip of liveVips) {
        const newMessageId = await processVip(guildId, vip, webhookUrl, messageIds[vip.twitchId]);
        if (newMessageId) {
            newMessages[vip.twitchId] = newMessageId;
        }
    }

    // Persist the new state of message IDs
    await db.collection(`communities/${guildId}/settings`).doc('vipLive').set({ vipMessageIds: newMessages }, { merge: true });
    
    return { liveVipCount: liveVips.length };
}


/**
 * This is the main entry point for the cron job.
 * It will iterate through all configured communities and run the VIP check.
 */
export async function GET(request: NextRequest) {
  try {
    const communitiesSnapshot = await db.collection('communities').get();
    if (communitiesSnapshot.empty) {
      return NextResponse.json({ success: true, message: 'No communities to process.' });
    }

    let totalLiveVips = 0;
    const results = [];

    for (const communityDoc of communitiesSnapshot.docs) {
        const guildId = communityDoc.id;
        console.log(`[Cron] Processing guild: ${guildId}`);
        const result = await runVipCheckForGuild(guildId);
        if (result) {
            totalLiveVips += result.liveVipCount;
            results.push({ guildId, liveVips: result.liveVipCount });
        }
    }

    return NextResponse.json({
      success: true,
      message: `Cron job completed. Processed ${communitiesSnapshot.size} guilds. Found ${totalLiveVips} live VIPs.`,
      details: results
    });

  } catch (error) {
    console.error('Cron job failed:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
```

---

## Part 2: Background Clip-to-GIF Cron Job

This is a background process designed to run less frequently (e.g., once every hour). Its sole purpose is to populate a library of GIFs for each VIP.

**File:** `/src/app/api/bot/cron-clips/route.ts`

```typescript
// src/app/api/bot/cron-clips/route.ts
import { NextResponse, type NextRequest } from 'next/server';
import { getAdminDb } from '@/lib/firebase-admin';
import { getTwitchClips, getClipById } from '@/app/actions';
import { generateGifFromUrl } from '@/ai/flows/generate-gif';
import { FieldValue } from 'firebase-admin/firestore';

const db = getAdminDb();

async function processClipsForGuild(guildId: string) {
    const usersSnapshot = await db.collection(`communities/${guildId}/users`).where('isVip', '==', true).get();
    if (usersSnapshot.empty) {
        console.log(`[Clip Cron] No VIPs found for guild ${guildId}.`);
        return { processed: 0, newGifs: 0 };
    }

    let newGifCount = 0;

    for (const userDoc of usersSnapshot.docs) {
        const userData = userDoc.data();
        const twitchId = userData.twitchInfo?.id;

        if (!twitchId) continue;

        try {
            const recentClips = await getTwitchClips(twitchId, 5);
            const gifsRef = userDoc.ref.collection('generatedGifs');

            for (const clip of recentClips) {
                const clipDocRef = gifsRef.doc(clip.id);
                const clipDoc = await clipDocRef.get();

                // If we haven't processed this clip before
                if (!clipDoc.exists) {
                    console.log(`[Clip Cron] New clip found for ${userData.twitchInfo.displayName}: ${clip.id}`);
                    const clipDetails = await getClipById(clip.id);

                    if (clipDetails?.video_url) {
                        const gifResult = await generateGifFromUrl({
                            videoUrl: clipDetails.video_url,
                            videoDuration: clipDetails.duration
                        });
                        
                        if (gifResult.gifUrl) {
                            await clipDocRef.set({
                                gifUrl: gifResult.gifUrl,
                                originalClipUrl: clip.url,
                                clipTitle: clip.title,
                                createdAt: FieldValue.serverTimestamp()
                            });
                            newGifCount++;
                            console.log(`[Clip Cron] Successfully generated and saved GIF for clip ${clip.id}`);
                        }
                    }
                }
            }
        } catch (error) {
            console.error(`[Clip Cron] Error processing clips for user ${userData.twitchInfo.displayName} (ID: ${twitchId}):`, error);
        }
    }
    return { processed: usersSnapshot.size, newGifs: newGifCount };
}


/**
 * This is the entry point for the clip generation cron job.
 * It will iterate through all configured communities and process clips for VIPs.
 */
export async function GET(request: NextRequest) {
  try {
    const communitiesSnapshot = await db.collection('communities').get();
    if (communitiesSnapshot.empty) {
      return NextResponse.json({ success: true, message: 'No communities to process.' });
    }

    const allResults = [];
    for (const communityDoc of communitiesSnapshot.docs) {
        const guildId = communityDoc.id;
        console.log(`[Clip Cron] Processing guild: ${guildId}`);
        const result = await processClipsForGuild(guildId);
        allResults.push({ guildId, ...result });
    }

    return NextResponse.json({
      success: true,
      message: `Clip cron job completed. Processed ${communitiesSnapshot.size} guilds.`,
      details: allResults
    });

  } catch (error) {
    console.error('Clip cron job failed:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
    return NextResponse.json({ success: false, error: errorMessage }, { status: 500 });
  }
}
```

---

## Part 3: AI Shoutout Generation Flow

This Genkit flow uses Gemini to create a witty, space-themed shoutout for a VIP.

**File:** `/src/ai/flows/generate-vip-shoutout.ts`

```typescript
'use server';
/**
 * @fileOverview A flow for generating a unique, space-themed shoutout for a VIP.
 *
 * - generateVipShoutout - A function that takes a VIP's name and returns a shoutout.
 * - GenerateVipShoutoutInput - The input type for the generateVipShoutout function.
 * - GenerateVipShoutoutOutput - The return type for the generateVipShoutout function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

export const GenerateVipShoutoutInputSchema = z.object({
  vipName: z.string().describe("The display name of the VIP streamer."),
});
export type GenerateVipShoutoutInput = z.infer<typeof GenerateVipShoutoutInputSchema>;

export const GenerateVipShoutoutOutputSchema = z.object({
  shoutoutMessage: z.string().describe("The generated witty, space-themed shoutout message."),
});
export type GenerateVipShoutoutOutput = z.infer<typeof GenerateVipShoutoutOutputSchema>;


export async function generateVipShoutout(
  input: GenerateVipShoutoutInput
): Promise<GenerateVipShoutoutOutput> {
  return generateVipShoutoutFlow(input);
}

const generateShoutoutPrompt = ai.definePrompt({
  name: 'generateVipShoutoutPrompt',
  input: {schema: GenerateVipShoutoutInputSchema},
  output: {schema: GenerateVipShoutoutOutputSchema},
  prompt: `You are a hype-person for a space-themed Twitch community called 'Cosmic Raid'.
  Your task is to generate a witty, fun, and epic space-themed shoutout message for a VIP streamer who has just gone live.
  The message should be between 300 and 400 characters. Use space and sci-fi metaphors.
  
  Generate a shoutout for the streamer: @{{{vipName}}}
  `,
  config: {
    temperature: 0.8,
  }
});

const generateVipShoutoutFlow = ai.defineFlow(
  {
    name: 'generateVipShoutoutFlow',
    inputSchema: GenerateVipShoutoutInputSchema,
    outputSchema: GenerateVipShoutoutOutputSchema,
  },
  async input => {
    const {output} = await generateShoutoutPrompt(input);
    return output!;
  }
);
```

---

## Part 4: GIF Generation Flow (FreeConvert API)

This Genkit flow takes a video URL and uses the FreeConvert API to convert it into a GIF.

**File:** `/src/ai/flows/generate-gif.ts`

```typescript
'use server';
/**
 * @fileOverview A flow for generating a GIF from a video URL using the FreeConvert API.
 * 
 * - generateGifFromUrl - A function that takes a video URL and returns the URL of the generated GIF.
 * - GenerateGifInput - The input type for the generateGifFromUrl function.
 * - GenerateGifOutput - The return type for the generateGifFromUrl function.
 */

import { ai } from '@/ai/genkit';
import { z } from 'zod';

const GenerateGifInputSchema = z.object({
  videoUrl: z.string().url().describe('The public URL of the video to convert to a GIF.'),
  videoDuration: z.number().optional().describe('The duration of the video in seconds.'),
});
export type GenerateGifInput = z.infer<typeof GenerateGifInputSchema>;

const GenerateGifOutputSchema = z.object({
  gifUrl: z.string().url().describe('The URL of the generated GIF file.'),
});
export type GenerateGifOutput = z.infer<typeof GenerateGifOutputSchema>;


// Main exported function that clients will call
export async function generateGifFromUrl(
  input: GenerateGifInput
): Promise<GenerateGifOutput> {
  return generateGifFlow(input);
}

// Helper function to delay execution
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));


async function createFreeConvertJob(videoUrl: string, videoDuration: number) {
    const FREECONVERT_TOKEN = process.env.FREECONVERT_TOKEN;
    if (!FREECONVERT_TOKEN) throw new Error("FREECONVERT_TOKEN is not configured in environment variables.");
    
    // Ensure duration is a positive number, default to 15s, cap at 60s.
    const durationInSeconds = (typeof videoDuration === 'number' && !isNaN(videoDuration) && videoDuration > 0) 
        ? Math.min(videoDuration, 60) 
        : 15;
    
    // Format as HH:MM:SS.sss
    const cutEnd = new Date(durationInSeconds * 1000).toISOString().slice(11, 23);

    const jobBody = {
        "tasks": {
            "import-1": {
                "operation": "import/url",
                "url": videoUrl
            },
            "convert-1": {
                "operation": "convert",
                "input": "import-1",
                "output_format": "gif",
                "options": {
                    "cut_start": "00:00:00.000",
                    "cut_end": cutEnd,
                    "width": 400,
                    "loop": 0,
                    "fps": 12,
                    "compression": 78
                }
            },
            "export-1": {
                "operation": "export/url",
                "input": "convert-1"
            }
        }
    };

    const res = await fetch("https://api.freeconvert.com/v1/process/jobs", {
        method: "POST",
        headers: { 
            "Content-Type": "application/json", 
            "Accept": "application/json", 
            "Authorization": `Bearer ${FREECONVERT_TOKEN}` 
        },
        body: JSON.stringify(jobBody),
    });
    
    const j = await res.json();
    if (!res.ok) {
        console.error("FreeConvert job creation failed:", JSON.stringify(j, null, 2));
        throw new Error(`FreeConvert job creation failed: ${JSON.stringify(j.message || j.errors || 'Unknown Error')}`);
    }
    return j;
}

async function pollFreeConvertJob(jobId: string, timeoutMs = 240000, intervalMs = 5000): Promise<any> {
    const FREECONVERT_TOKEN = process.env.FREECONVERT_TOKEN;
    if (!FREECONVERT_TOKEN) throw new Error("FREECONVERT_TOKEN is not configured in environment variables.");

    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
        const res = await fetch(`https://api.freeconvert.com/v1/process/jobs/${jobId}`, {
            headers: { 
                "Accept": "application/json", 
                "Authorization": `Bearer ${FREECONVERT_TOKEN}` 
            }
        });
        
        const j = await res.json();
        
        if (j.status === "finished") {
            const exportTask = Object.values(j.tasks || {}).find((t: any) => t.operation === "export/url");
            if (exportTask && (exportTask as any).status === "finished" && (exportTask as any).result?.url) {
                return (exportTask as any).result;
            } else {
                 const failedTask = Object.values(j.tasks || {}).find((t: any) => t.status === "failed");
                 const errorMessage = (failedTask as any)?.result?.message || "Export task did not complete successfully or URL was missing.";
                 console.error("FreeConvert job finished but export task failed:", JSON.stringify(j, null, 2));
                 throw new Error(`FreeConvert job finished but export task failed: ${errorMessage}`);
            }
        } else if (j.status === "failed") {
            console.error("FreeConvert job failed:", JSON.stringify(j, null, 2));
            const failedTask = Object.values(j.tasks || {}).find((t: any) => t.status === "failed");
            const errorMessage = (failedTask as any)?.result?.message || "Unknown processing error.";
            throw new Error(`FreeConvert job failed: ${errorMessage}`);
        }
        
        await sleep(intervalMs);
    }
    
    throw new Error("FreeConvert job polling timed out after 4 minutes.");
}

// Genkit Flow Definition
const generateGifFlow = ai.defineFlow(
  {
    name: 'generateGifFlow',
    inputSchema: GenerateGifInputSchema,
    outputSchema: GenerateGifOutputSchema,
  },
  async ({ videoUrl, videoDuration }) => {
    if (!process.env.FREECONVERT_TOKEN) {
        throw new Error('FREECONVERT_TOKEN is not configured in environment variables.');
    }
    
    const job = await createFreeConvertJob(videoUrl, videoDuration || 15);
    const jobId = job.id;

    if (!jobId) {
        throw new Error("Failed to get Job ID from FreeConvert job creation response.");
    }
    
    const result = await pollFreeConvertJob(jobId, 240000);
    const gifUrl = result?.url;

    if (!gifUrl) {
      throw new Error('GIF rendering failed or timed out. No URL was returned.');
    }

    return { gifUrl };
  }
);
```
