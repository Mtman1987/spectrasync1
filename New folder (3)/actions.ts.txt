
// src/app/actions.ts
'use server';

import { getAdminDb } from '@/lib/firebase-admin';
import { FieldValue, FieldPath, Timestamp } from 'firebase-admin/firestore';
import type { LiveUser } from './raid-pile/types';
import { getSettings } from './settings/actions';


// --- DISCORD API ACTIONS ---

/**
 * Fetches a Discord user's profile using the bot token.
 * This is a server-to-server call and does not require OAuth2.
 */
export async function getDiscordUser(discordId: string): Promise<{ id: string, username: string, avatar: string | null } | null> {
    if (!process.env.DISCORD_BOT_TOKEN) {
        console.error("Discord Bot Token is not configured in environment variables.");
        return null;
    }
    try {
        const url = `https://discord.com/api/v10/users/${discordId}`;
        const response = await fetch(url, {
            headers: {
                'Authorization': `Bot ${process.env.DISCORD_BOT_TOKEN}`
            }
        });

        if (!response.ok) {
            console.error(`Discord API error (getUser): ${response.status} ${await response.text()}`);
            return null;
        }

        const userData = await response.json();
        return {
            id: userData.id,
            username: userData.username,
            avatar: userData.avatar ? `https://cdn.discordapp.com/avatars/${userData.id}/${userData.avatar}.png` : null,
        };

    } catch (error) {
        console.error("Error fetching Discord user:", error);
        return null;
    }
}

/**
 * Fetches details for a specific Discord guild (server) using the bot token.
 */
export async function getGuildDetails(guildId: string): Promise<{ id: string, name: string, icon: string | null } | null> {
     if (!process.env.DISCORD_BOT_TOKEN) {
        console.error("Discord Bot Token is not configured.");
        return null;
    }
     if (!guildId) return null;

    try {
        const url = `https://discord.com/api/v10/guilds/${guildId}`;
        const response = await fetch(url, {
            headers: { 'Authorization': `Bot ${process.env.DISCORD_BOT_TOKEN}` },
             next: { revalidate: 3600 } // Cache the result for 1 hour
        });
        if (!response.ok) {
            console.error(`Discord API error (getGuildDetails for ${guildId}): ${response.status} ${await response.text()}`);
            // Return a fallback so the UI doesn't break
            return { id: guildId, name: `Guild ${guildId.slice(-4)}`, icon: null };
        }
        const guildData = await response.json();
        const iconUrl = guildData.icon ? `https://cdn.discordapp.com/icons/${guildData.id}/${guildData.icon}.png` : null;

        return {
            id: guildData.id,
            name: guildData.name,
            icon: iconUrl,
        };
    } catch (error) {
        console.error(`Error fetching guild details for ${guildId}:`, error);
        return { id: guildId, name: `Guild ${guildId.slice(-4)}`, icon: null };
    }
}


// --- TWITCH API ACTIONS ---

let appAccessToken: { token: string, expires_at: number } | null = null;

async function getTwitchAppAccessToken() {
    if (appAccessToken && Date.now() < appAccessToken.expires_at) {
        return appAccessToken.token;
    }

    if (!process.env.TWITCH_CLIENT_ID || !process.env.TWITCH_CLIENT_SECRET) {
        throw new Error("Twitch client ID or secret is not configured in environment variables.");
    }

    const url = `https://id.twitch.tv/oauth2/token?client_id=${process.env.TWITCH_CLIENT_ID}&client_secret=${process.env.TWITCH_CLIENT_SECRET}&grant_type=client_credentials`;
    const response = await fetch(url, { method: 'POST' });
    const data = await response.json();

    if (!response.ok) {
        throw new Error(`Failed to get Twitch app access token: ${data.message || 'Unknown error'}`);
    }

    appAccessToken = {
        token: data.access_token,
        expires_at: Date.now() + (data.expires_in * 1000)
    };

    return appAccessToken.token;
}

export async function getTwitchUserByUsername(username: string): Promise<{ id: string, login: string, display_name: string, profile_image_url: string } | null> {
    if (!process.env.TWITCH_CLIENT_ID) {
        console.error("Twitch Client ID is not set.");
        return null;
    }
    try {
        const accessToken = await getTwitchAppAccessToken();
        const url = `https://api.twitch.tv/helix/users?login=${username.toLowerCase()}`;
        
        const response = await fetch(url, {
            headers: {
                'Client-ID': process.env.TWITCH_CLIENT_ID,
                'Authorization': `Bearer ${accessToken}`
            }
        });

        if (!response.ok) {
            console.error(`Twitch API error: ${response.status} ${await response.text()}`);
            return null;
        }

        const data = await response.json();

        if (data.data && data.data.length > 0) {
            return data.data[0];
        } else {
            return null;
        }
    } catch (error) {
        console.error("Error fetching Twitch user by username:", error);
        return null;
    }
}


export async function getTwitchStreams(userIds: string[]): Promise<any[]> {
    if (userIds.length === 0) return [];

    if (!process.env.TWITCH_CLIENT_ID) {
        console.error("Twitch Client ID is not set.");
        return [];
    }
    try {
        const accessToken = await getTwitchAppAccessToken();
        const params = new URLSearchParams();
        userIds.forEach(id => params.append('user_id', id));
        
        const url = `https://api.twitch.tv/helix/streams?${params.toString()}`;
        
        const response = await fetch(url, {
            headers: {
                'Client-ID': process.env.TWITCH_CLIENT_ID,
                'Authorization': `Bearer ${accessToken}`
            }
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.error(`Twitch API error (getStreams): ${response.status} - ${errorText}`);
            // Return empty array but log the error for diagnosis
            return [];
        }

        const data = await response.json();
        return data.data || [];

    } catch (error) {
        console.error("Error fetching Twitch streams:", error);
        return [];
    }
}

export async function getClipById(clipId: string): Promise<any> {
    if (!process.env.TWITCH_CLIENT_ID) {
        throw new Error('Twitch Client ID is not set.');
    }
    const accessToken = await getTwitchAppAccessToken();
    const url = `https://api.twitch.tv/helix/clips?id=${clipId}`;
    const response = await fetch(url, {
        headers: {
            'Client-ID': process.env.TWITCH_CLIENT_ID,
            'Authorization': `Bearer ${accessToken}`
        }
    });

    if (!response.ok) {
        throw new Error(`Twitch API error (getClipById): ${response.status} ${await response.text()}`);
    }

    const data = await response.json();
    if (!data.data || data.data.length === 0) {
        throw new Error(`Clip with ID ${clipId} not found.`);
    }

    const clip = data.data[0];
    
    // This is the correct, reliable way to get the video URL
    const videoUrl = clip.thumbnail_url.replace(/-preview-.*\.jpg$/, '.mp4');
    
    if (!videoUrl) {
        throw new Error("Could not construct video URL from thumbnail.");
    }
    
    return { ...clip, video_url: videoUrl };
}

export async function getTwitchClips(broadcasterId: string, limit = 5): Promise<any[]> {
     if (!process.env.TWITCH_CLIENT_ID) {
        console.error("Twitch Client ID is not set.");
        return [];
    }
    try {
        const accessToken = await getTwitchAppAccessToken();
        const startedAt = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(); // last 7 days

        const url = `https://api.twitch.tv/helix/clips?broadcaster_id=${broadcasterId}&first=${limit}&started_at=${startedAt}`;
        
        const response = await fetch(url, {
            headers: {
                'Client-ID': process.env.TWITCH_CLIENT_ID,
                'Authorization': `Bearer ${accessToken}`
            }
        });

        if (!response.ok) {
            console.error(`Twitch API error (getClips): ${response.status} ${await response.text()}`);
            return [];
        }

        const data = await response.json();
        return data.data || [];

    } catch (error) {
        console.error("Error fetching Twitch clips:", error);
        return [];
    }
}


// --- USER-FOCUSED ACTIONS ---

/**
 * Saves or updates information for a specific user (community member) using their Discord ID as the primary key.
 * This will create/update a document at `communities/{guildId}/users/{discordId}`.
 */
export async function saveUserInfoByDiscordId(guildId: string, discordId: string, data: any) {
  if (!guildId || !discordId) {
    console.error("Error saving user info: guildId and discordId are required.");
    return { success: false, error: "Community ID and Discord User ID are required." };
  }
  try {
    const adminDb = getAdminDb();
    const userRef = adminDb.collection('communities').doc(guildId).collection('users').doc(discordId);
    await userRef.set(data, { merge: true });
    console.log(`User info saved for user ${discordId} in guild ${guildId}`);
    return { success: true };
  } catch (e) {
    console.error(`Error saving user info for user ${discordId} in guild ${guildId}: `, e);
    const errorMessage = e instanceof Error ? e.message : String(e);
    return { success: false, error: errorMessage };
  }
}

/**
 * Retrieves all information for a specific user (community member) using their Discord ID.
 */
export async function getUserInfoByDiscordId(guildId: string, discordId: string): Promise<{ value: any | null, error?: string }> {
    if (!guildId || !discordId) {
        return { value: null, error: "Community ID and Discord User ID are required." };
    }
    try {
        const adminDb = getAdminDb();
        const docRef = adminDb.collection('communities').doc(guildId).collection('users').doc(discordId);
        const doc = await docRef.get();

        if (!doc.exists) {
            console.log(`User document does not exist at path: ${docRef.path}`);
            return { value: null }; 
        }
        
        return { value: doc.data() || null };

    } catch (e) {
        console.error(`Error getting user info for discordId ${discordId} in guild ${guildId}: `, e);
        const errorMessage = e instanceof Error ? e.message : String(e);
        return { value: null, error: errorMessage };
    }
}


// --- ADMIN-FOCUSED ACTIONS ---

/**
 * Saves or updates information for an ADMIN using their Discord ID as the primary key.
 * This will create/update a document at the global `admins/{discordId}` path.
 */
export async function saveAdminInfo(discordId: string, data: any) {
  if (!discordId) {
    return { success: false, error: "Discord ID is required." };
  }
  try {
    const adminDb = getAdminDb();
    const adminRef = adminDb.collection('admins').doc(discordId);
    await adminRef.set(data, { merge: true });
    return { success: true };
  } catch (e) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    return { success: false, error: errorMessage };
  }
}

/**
 * Retrieves all information for a specific ADMIN using their Discord ID.
 */
export async function getAdminInfo(discordId: string): Promise<{ value: any | null, error?: string }> {
  if (!discordId) {
    return { value: null, error: "Discord ID is required." };
  }
  try {
    const adminDb = getAdminDb();
    const docRef = adminDb.collection('admins').doc(discordId);
    const doc = await docRef.get();

    if (!doc.exists) {
      console.log(`Admin document does not exist at path: ${docRef.path}`);
      return { value: null };
    }

    return { value: doc.data() || null };
  } catch (e) {
    const errorMessage = e instanceof Error ? e.message : String(e);
    console.error(`Error getting admin info for discordId ${discordId}:`, errorMessage);
    return { value: null, error: errorMessage };
  }
}

/**
 * Adds a new guild to the admin's list of manageable guilds.
 * This function now expects the full guild object to be passed in.
 */
export async function addManagedGuild(adminDiscordId: string, newGuild: { id: string, name: string, icon: string | null }) {
    if (!adminDiscordId || !newGuild || !newGuild.id) {
        return { success: false, error: "Admin ID and Guild Info are required." };
    }
    try {
        const adminDb = getAdminDb();
        const adminRef = adminDb.collection('admins').doc(adminDiscordId);
        await adminRef.update({
            discordUserGuilds: FieldValue.arrayUnion(newGuild)
        });
        
        return { success: true, message: `Successfully added "${newGuild.name}" to your managed communities.` };
    } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        return { success: false, error: errorMessage };
    }
}


/**
 * Retrieves the currently selected guild for the admin from their global admin document.
 */
export async function getSelectedGuildId(adminDiscordId: string): Promise<string | null> {
    if (!adminDiscordId) return null;
    try {
        const { value, error } = await getAdminInfo(adminDiscordId);
        if (error) {
            console.error("Error getting selected guild ID:", error);
            return null;
        }
        return value?.selectedGuild || null;
    } catch (error) {
        console.error("Error in getSelectedGuildId:", error);
        return null;
    }
}


/**
 * Saves a user's Twitch info to the specific `communities/{guildId}/users` collection.
 * This is used during the initial setup flow triggered by the bot.
 */
export async function saveUserTwitchInfo(guildId: string, discordId: string, discordUsername: string, discordAvatar: string | null, twitchUsername: string) {
    if (!guildId || !discordId || !twitchUsername) {
        return { success: false, error: "Community ID, Discord ID, and Twitch Username are required." };
    }
    
    try {
        const db = getAdminDb();
        const twitchUser = await getTwitchUserByUsername(twitchUsername);

        if (!twitchUser) {
            return { success: false, error: `Could not find a Twitch user with the username "${twitchUsername}". Please check the spelling.` };
        }

        const userData = {
            discordInfo: {
                id: discordId,
                username: discordUsername,
                avatar: discordAvatar,
            },
            twitchInfo: {
                id: twitchUser.id,
                displayName: twitchUser.display_name,
                avatar: twitchUser.profile_image_url,
                login: twitchUser.login,
            },
        };

        const userRef = db.collection('communities').doc(guildId).collection('users').doc(discordId);
        await userRef.set(userData, { merge: true });

        return { success: true };

    } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        return { success: false, error: errorMessage };
    }
}

/**
 * Saves the ADMIN's Twitch info to their global admin profile.
 */
export async function saveAdminTwitchInfo(adminDiscordId: string, twitchUsername: string) {
    if (!adminDiscordId || !twitchUsername) {
        return { success: false, error: "Admin Discord ID and Twitch Username are required." };
    }

    try {
        const twitchUser = await getTwitchUserByUsername(twitchUsername);
        if (!twitchUser) {
            return { success: false, error: `Could not find a Twitch user with the username "${twitchUsername}". Please check the spelling.` };
        }

        const adminTwitchData = {
            twitchInfo: {
                id: twitchUser.id,
                displayName: twitchUser.display_name,
                avatar: twitchUser.profile_image_url,
                login: twitchUser.login,
            },
        };

        return await saveAdminInfo(adminDiscordId, adminTwitchData);
    } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);
        return { success: false, error: errorMessage };
    }
}


// This is a placeholder for a more advanced function that would get live status from Twitch
export async function getLiveUsersFromTwitch(userIds: string[]): Promise<{ [key: string]: Pick<LiveUser, 'latestGameName' | 'latestViewerCount' | 'latestStreamTitle' | 'started_at'> }> {
    if (userIds.length === 0) return {};
    
    const streams = await getTwitchStreams(userIds);

    const liveData: { [key: string]: Pick<LiveUser, 'latestGameName' | 'latestViewerCount' | 'latestStreamTitle' | 'started_at'> } = {};

    streams.forEach(stream => {
        liveData[stream.user_id] = {
            latestGameName: stream.game_name,
            latestViewerCount: stream.viewer_count,
            latestStreamTitle: stream.title,
            started_at: stream.started_at,
        };
    });

    return liveData;
}


export async function getUsersFromDb(guildId: string, userIds: string[]): Promise<LiveUser[]> {
    if (userIds.length === 0) return [];
    const db = getAdminDb();
    const usersCollection = db.collection(`communities/${guildId}/users`);
    
    // Firestore 'in' queries are limited to 30 elements. We might need to chunk this.
    // For now, assuming userIds length is within limits.
    const userDocs = await usersCollection.where('twitchInfo.id', 'in', userIds).get();
    
    return userDocs.docs.map(doc => {
        const data = doc.data();
        const twitchInfo = data.twitchInfo || {};
        const discordInfo = data.discordInfo || {};
        return {
            discordId: discordInfo.id,
            twitchId: twitchInfo.id,
            twitchLogin: twitchInfo.login,
            displayName: twitchInfo.displayName,
            avatarUrl: twitchInfo.avatar,
            latestGameName: '', // This will be filled by Twitch data
            latestViewerCount: 0, // This will be filled by Twitch data
            vipMessage: data.vipMessage || undefined,
            points: data.points || 0,
            lastHeldRaidPile: data.lastHeldRaidPile || undefined
        }
    });
}

export async function getLiveRaidPiles(guildId: string) {
    if (!guildId) {
        console.error("No guildId provided to getLiveRaidPiles");
        return [];
    }
    try {
        const db = getAdminDb();
        const usersSnapshot = await db.collection(`communities/${guildId}/users`).where("inPile", "==", true).get();
        
        if (usersSnapshot.empty) {
            return [];
        }
        
        const userIds = usersSnapshot.docs.map(doc => doc.data().twitchInfo?.id).filter(Boolean);
        
        if (userIds.length === 0) {
            console.log("Found users in pile, but they are missing Twitch IDs.");
            return [];
        }
        
        const [dbUsers, liveTwitchData] = await Promise.all([
             getUsersFromDb(guildId, userIds),
             getLiveUsersFromTwitch(userIds)
        ]).catch(err => {
            console.error("Error fetching data for raid pile:", err);
            return [[], {}]; // Return empty arrays on error
        });
        
        const threeDaysAgo = Date.now() - 3 * 24 * 60 * 60 * 1000;

        const liveUsers = dbUsers.map(user => {
            const twitchData = liveTwitchData[user.twitchId];
            return twitchData ? { ...user, ...twitchData } : null;
        }).filter((u): u is LiveUser => u !== null)
         .filter(user => {
             if (!user.lastHeldRaidPile) return true; // Always include if they've never been holder
             const lastHeldMs = (user.lastHeldRaidPile as unknown as Timestamp).toMillis();
             return lastHeldMs < threeDaysAgo;
         })
         .sort((a, b) => a.latestViewerCount - b.latestViewerCount);
        
        let holder = liveUsers.length > 0 ? liveUsers[0] : null;

        if (holder) {
            const holderUserRef = db.collection(`communities/${guildId}/users`).where('twitchInfo.id', '==', holder.twitchId);
            const holderSnapshot = await holderUserRef.get();
            if(!holderSnapshot.empty) {
                const holderDocRef = holderSnapshot.docs[0].ref;
                await holderDocRef.update({ lastHeldRaidPile: FieldValue.serverTimestamp() });
            }
        }
        
        const pile = {
            holder: holder,
            liveUsers: liveUsers,
            totalViewers: liveUsers.reduce((sum, user) => sum + user.latestViewerCount, 0),
        };

        return [pile];
    } catch (error) {
        console.error(`Error getting live raid piles for guild ${guildId}:`, error);
        return [];
    }
}

export async function getLiveCommunityPoolUsers(guildId: string): Promise<LiveUser[]> {
     if (!guildId) {
        console.error("No guildId provided to getLiveCommunityPoolUsers");
        return [];
    }
    try {
        const db = getAdminDb();
        const usersSnapshot = await db.collection(`communities/${guildId}/users`).where("inCommunityPool", "==", true).get();

        if (usersSnapshot.empty) {
            return [];
        }

        const userIds = usersSnapshot.docs.map(doc => doc.data().twitchInfo.id).filter(Boolean);
        const [dbUsers, liveTwitchData] = await Promise.all([
             getUsersFromDb(guildId, userIds),
             getLiveUsersFromTwitch(userIds)
        ]);

        const liveUsers = dbUsers.map(user => {
            const twitchData = liveTwitchData[user.twitchId];
            return twitchData ? { ...user, ...twitchData } : null;
        }).filter((u): u is LiveUser => u !== null);

        return liveUsers;

    } catch (error) {
        console.error(`Error getting live community pool users for guild ${guildId}:`, error);
        return [];
    }
}

export async function getLiveVipUsers(guildId: string): Promise<LiveUser[]> {
    if (!guildId) {
       console.error("No guildId provided to getLiveVipUsers");
       return [];
   }
   try {
        const db = getAdminDb();
        const usersSnapshot = await db.collection(`communities/${guildId}/users`).where("isVip", "==", true).get();

        if (usersSnapshot.empty) {
           return [];
        }

        const userIds = usersSnapshot.docs.map(doc => doc.data().twitchInfo?.id).filter(Boolean);

        if (userIds.length === 0) return [];
        
        const [dbUsers, liveTwitchData] = await Promise.all([
             getUsersFromDb(guildId, userIds),
             getLiveUsersFromTwitch(userIds)
        ]);

        const liveUsers = dbUsers.map(user => {
            const twitchData = liveTwitchData[user.twitchId];
            return twitchData ? { ...user, ...twitchData } : null;
        }).filter((u): u is LiveUser => u !== null);
       
       return liveUsers;

   } catch (error) {
       console.error(`Error getting live VIP users for guild ${guildId}:`, error);
       return [];
   }
}


export async function joinPile(guildId: string, discordId: string) {
  if (!guildId) return { success: false, error: "Community ID is missing." };
  if (!discordId) return { success: false, error: "User info is missing." };
  try {
    const db = getAdminDb();
    const userRef = db.collection(`communities/${guildId}/users`).doc(discordId);

    await db.runTransaction(async (transaction) => {
        const userDoc = await transaction.get(userRef);
        
        if (!userDoc.exists || !userDoc.data()?.twitchInfo) {
            throw new Error("User has not linked their Twitch account yet.");
        }

        transaction.set(userRef, { inPile: true }, { merge: true });
    });

    return { success: true };

  } catch (error) {
    console.error("Error joining pile:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return { success: false, error: errorMessage };
  }
}

export async function joinCommunityPool(guildId: string, discordId: string) {
  if (!guildId) return { success: false, error: "Community ID is missing." };
  if (!discordId) return { success: false, error: "User info is missing." };
  try {
    const db = getAdminDb();
    const userRef = db.collection(`communities/${guildId}/users`).doc(discordId);

     await db.runTransaction(async (transaction) => {
        const userDoc = await transaction.get(userRef);
        if (!userDoc.exists || !userDoc.data()?.twitchInfo) {
            throw new Error("User has not linked their Twitch account yet.");
        }
        transaction.set(userRef, { inCommunityPool: true }, { merge: true });
     });

    return { success: true };
  } catch (error) {
    console.error("Error joining community pool:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    return { success: false, error: errorMessage };
  }
}


export async function leavePile(guildId: string, userId: string) {
    if (!guildId) return { success: false, error: "Community ID is missing." };
    if (!userId) return { success: false, error: "User ID is missing." };
    try {
        const db = getAdminDb();
        const userRef = db.collection(`communities/${guildId}/users`).doc(userId);
        
        await userRef.update({ inPile: false });

        return { success: true };
    } catch (error) {
        console.error("Error leaving pile:", error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}

export async function addVip(guildId: string, twitchUsername: string, vipMessage: string) {
    if (!guildId || !twitchUsername) {
        return { success: false, error: "Community ID and Twitch Username are required." };
    }
    try {
        const db = getAdminDb();
        const twitchUser = await getTwitchUserByUsername(twitchUsername);

        if (!twitchUser) {
            return { success: false, error: `Could not find a Twitch user with the username "${twitchUsername}".` };
        }

        const userQuery = await db.collection(`communities/${guildId}/users`).where('twitchInfo.id', '==', twitchUser.id).limit(1).get();
        
        if (userQuery.empty) {
            // User doesn't exist, create them. We use their Twitch ID as the document ID for consistency.
            const newUserRef = db.collection(`communities/${guildId}/users`).doc(twitchUser.id);
            await newUserRef.set({
                twitchInfo: {
                    id: twitchUser.id,
                    displayName: twitchUser.display_name,
                    avatar: twitchUser.profile_image_url,
                    login: twitchUser.login,
                },
                isVip: true,
                vipMessage: vipMessage,
                vipAddedAt: FieldValue.serverTimestamp(),
            }, { merge: true });
        } else {
            // User exists, update them.
            const userRef = userQuery.docs[0].ref;
            await userRef.set({
                isVip: true,
                vipMessage: vipMessage,
                vipAddedAt: FieldValue.serverTimestamp(),
            }, { merge: true });
        }

        return { success: true, message: `${twitchUser.display_name} has been added as a VIP.` };

    } catch (error) {
        console.error("Error adding VIP:", error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}

export async function createAndAddVip(guildId: string, discordId: string, twitchUsername: string, vipMessage: string) {
    if (!guildId || !discordId || !twitchUsername) {
        return { success: false, error: "Community ID, Discord ID, and Twitch Username are required." };
    }
    try {
        const db = getAdminDb();
        const twitchUser = await getTwitchUserByUsername(twitchUsername);

        if (!twitchUser) {
            return { success: false, error: `Could not find a Twitch user with the username "${twitchUsername}".` };
        }

        const userRef = db.collection('communities').doc(guildId).collection('users').doc(discordId);
        
        const userData = {
            discordInfo: {
                id: discordId,
                username: `user_${discordId.substring(0, 5)}`, // Placeholder
                avatar: null,
            },
            twitchInfo: {
                id: twitchUser.id,
                displayName: twitchUser.display_name,
                avatar: twitchUser.profile_image_url,
                login: twitchUser.login,
            },
            isVip: true,
            vipMessage: vipMessage,
            vipAddedAt: FieldValue.serverTimestamp(),
        };

        await userRef.set(userData, { merge: true });

        return { success: true, message: `${twitchUser.display_name} has been created and added as a VIP.` };

    } catch (error) {
        console.error("Error creating and adding VIP:", error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}

export async function removeVip(guildId: string, discordId: string) {
    if (!guildId || !discordId) {
        return { success: false, error: "Community ID and Discord ID are required." };
    }
    try {
        const db = getAdminDb();
        const userRef = db.collection(`communities/${guildId}/users`).doc(discordId);

        const userDoc = await userRef.get();
        if (!userDoc.exists) {
            return { success: false, error: "User not found." };
        }

        await userRef.update({
            isVip: false,
            vipMessage: FieldValue.delete(),
            vipAddedAt: FieldValue.delete(),
        });

        const displayName = userDoc.data()?.twitchInfo?.displayName || 'The user';
        return { success: true, message: `${displayName} is no longer a VIP.` };

    } catch (error) {
        console.error("Error removing VIP:", error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}

/**
 * Updates a VIP's information, such as their custom message.
 */
export async function updateVip(guildId: string, discordId: string, vipMessage: string) {
    if (!guildId || !discordId) {
        return { success: false, error: "Community ID and Discord ID are required." };
    }
    try {
        const db = getAdminDb();
        const userRef = db.collection(`communities/${guildId}/users`).doc(discordId);
        
        const userDoc = await userRef.get();
        if (!userDoc.exists) {
            return { success: false, error: "VIP user not found." };
        }

        await userRef.update({ vipMessage: vipMessage });

        const displayName = userDoc.data()?.twitchInfo?.displayName || 'The user';
        return { success: true, message: `VIP message for ${displayName} has been updated.` };
    } catch (error) {
        console.error("Error updating VIP:", error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}


/**
 * Adds a specified number of points to the admin's user document for the given community.
 * This is intended as a testing/debugging tool.
 */
export async function addPointsToAdmin(guildId: string, adminDiscordId: string, pointsToAdd: number) {
  if (!guildId || !adminDiscordId) {
    return { success: false, error: "Community ID and Admin ID are required." };
  }
  try {
    const db = getAdminDb();
    // The admin's community-specific user data is in the `users` collection for that guild, keyed by their discord ID.
    const userRef = db.collection('communities').doc(guildId).collection('users').doc(adminDiscordId);
    
    const userDoc = await userRef.get();
    
    // An admin might not have a `users` document if they haven't linked their Twitch account via the bot flow yet.
    // We can create a shell document for them to add points to.
    if (!userDoc.exists) {
        // Attempt to get Discord user info to create a shell profile
        const discordUser = await getDiscordUser(adminDiscordId);
        if (discordUser) {
             await userRef.set({
                discordInfo: {
                    id: discordUser.id,
                    username: discordUser.username,
                    avatar: discordUser.avatar,
                },
                points: pointsToAdd
             }, { merge: true });
        } else {
            throw new Error("Could not find Discord profile to create user document.");
        }
    } else {
        await userRef.update({
            points: FieldValue.increment(pointsToAdd)
        });
    }

    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error("Error adding points to admin:", error);
    return { success: false, error: errorMessage };
  }
}

    

    

